# レイヤードアーキテクチャ  

```text
┌─────────────────────────────────────┐
│         Controller Layer            │  ← HTTPリクエスト/レスポンス
│  - リクエストの受付                   │
│  - レスポンスの返却                   │
│  - ステータスコードの設定              │
└─────────────────────────────────────┘
               ↓
┌─────────────────────────────────────┐
│          Service Layer              │  ← ビジネスロジック
│  - バリデーション                     │
│  - ビジネスルールの適用               │
│  - 複数Repositoryの組み合わせ         │
└─────────────────────────────────────┘
               ↓
┌─────────────────────────────────────┐
│        Repository Layer             │  ← データアクセス
│  - データの永続化・取得               │
│  - SQLクエリ（将来的にPrisma）        │
└─────────────────────────────────────┘
               ↓
┌─────────────────────────────────────┐
│           Database                  │
│  - PostgreSQL（将来的に）             │
│  - メモリDB（現在）                   │
└─────────────────────────────────────┘


  なぜこのアーキテクチャか？
  
  1. 単一責任の原則
     各層が一つの責務のみを持つ
  
  2. テスタビリティ
     各層を独立してテストできる
  
  3. 保守性
     変更の影響範囲が限定的
     例: データベースをPostgreSQLからMongoDBに変更
     → Repository層のみ修正すればOK
  
  4. スケーラビリティ
     Service層を複数のマイクロサービスに分割可能
  
  実務での評価基準:
  - ジュニア: 全部index.tsに書く
  - ミドル: 層を分離できる ← あなたが目指すレベル
  - シニア: アーキテクチャを設計できる

  なぜこのアーキテクチャか？
  
  1. 単一責任の原則
     各層が一つの責務のみを持つ
  
  2. テスタビリティ
     各層を独立してテストできる
  
  3. 保守性
    変更の影響範囲が限定的
    例: データベースをPostgreSQLからMongoDBに変更
    → Repository層のみ修正すればOK
  
  4. スケーラビリティ
     Service層を複数のマイクロサービスに分割可能
  
  実務での評価基準:

- ジュニア: 全部index.tsに書く
- ミドル: 層を分離できる ← あなたが目指すレベル
- シニア: アーキテクチャを設計できる
